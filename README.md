# Algorithms Lab 5 Boyer - Moore Algorithm

## boyes_moore_substring.py.py
##BoyesMooreSubstring
### def precompile
1.Робить прекомпіляцію шаблона. Для початку створюється лист у розмірі кількості достатього алфавіту. Потім цикл перебирає 
всі симоволи і виставляє зміщення символа у масив якій індексується номером цього символа у тому чі іншому форматі.
### def precompile
```python
       def precompile(self,sting,size):
        bad_char = [-1]*self.alphabet
        for i in range(size):
            bad_char[ord(sting[i])]=i
        return bad_char
```
### def count_chain
2. Для початку у фунції знадиться розмір шаблона і текста. Потім прекомпілюємо данний функції шаблон і після цього оголошуємо shift.
shift - значення яке показує на скільки функція змістилась у перевірці значень. Поскільки сканування іде з ліва на право, то shift = 0.
Потім виконується цикл умовою якого є те, що shift не має іти далі різниці загальною довжини тексту та шаблона.
Поскільки саме порівняння іде з права на ліво, align на початку зберігає зміщення шаблона до останнього символа включо.
Потім іде перевірка - якщо символ самого тексту який має індекс суми зміщення відносно тексту та слова є відповідно рівним до символу що влючається
в останнє зміщення шаблону ( простішими словами остання буква ), то зміщення іде в ліву сторону і далі звіряє символи шаблону та тексту на цьому рівні зміщення відносно тексту.
Якщо зміщення відносно шаблону дійшло до -1, можна зрозуміти що кожен символ на цьому рівні зміщення і до рівня зміщення шаблону є однаковим. Тобто слово знайдене.
Якщо більше рівне 0, то це значить що не кожен символ відповідає шаблону і слово не знайдене.
Потім іде перевірка. Якщо слово знайшлось - ми його добавляємо до масиву ідексів result які зберігають в собі зміщення відносно 0 елементу масиву символів.
Після цього звіряється символ відносно наступного символа після знайденого слова. Якщо символу немає в заготовленому прекомпільованому масиві, це значить що можливість коли слово,яке
піддалось провірці, містить в собі частинку ще одного шаблона - не виправдалась. Тоді зміщення відносно тексту переходить на символ якій ще має надію піддатись провірці ( для того було і виставленні -1 
в масив, бо так ми переходим на новий символ який ще не піддавався провірці). У разі якщо є збіг символу - зміщення відносно тексту вирівнює символ шаблону який  збігся ( через масив в якому ми записали
зміщення символів шаблону) і потім на новій ітерації циклу в дочірньому циклі ми провіряємо чи там є якийсь збіг. 
У разі якщо збігу ніякого немає, функція шукає останній провірений символ. Якщо такий символ існує в шаблоні - функція знову ж таки вирівнює зміщення під цей символ і провіряє на новій ітерації звіряє чи там щось є.
Якщо символ не збігається - зміщення переступає через те що мало надію піддатись шаблону. 

```python
       def search(self,pattern):
        result = []
        len_pattern = len(pattern)
        len_txt = len(self.string)
        bad_char = self.precompile(pattern,len_pattern)
        shift = 0
        while shift <= (len_txt - len_pattern):
            align = len_pattern-1

            while align >= 0 and pattern[align]==self.string[shift+align]:
                align -= 1

            if align<0:
                result.append(shift)
                if (shift + len_pattern) >= len_txt: break
                next_letter = self.string[shift + len_pattern]
                next_shift = bad_char[ord(next_letter)]
                shift += len_pattern - next_shift
            else:
                if (shift + align) >= len_txt: break
                align_letter = self.string[shift + align]
                next_shift = bad_char[ord(align_letter)]
                shift += max(1,align - next_shift)

        return result

```

# Іnstalation
## Для реквестів:git clone https://github.com/thefreekley/Lab5-Algo3.git
## Для запуску: python main.py
